# Study Unreal IdeuGu GAS

## 참고

### 인프런

[이득우의 언리얼 프로그래밍 Part4 - 게임플레이 어빌리티 시스템](https://www.inflearn.com/course/%EC%9D%B4%EB%93%9D%EC%9A%B0-%EC%96%B8%EB%A6%AC%EC%96%BC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-part-4/dashboard)

### GitHub

[ideugu/UnrealGAS1](https://github.com/ideugu/UnrealGAS1)

## 강의 목차

1. 게임플레이 어빌리티 시스템 시작
    - 액터를 활용한 GAS의 기본 동작 원리 파악
2. 캐릭터의 입력 처리
    - 입력에 대응하는 게임플레이 어빌리티 발동
    - 게임플레이 어빌리티의 구현
3. 캐릭터의 콤보 공격 구현
    - 게임플레이 어빌리티의 상세 구현
4. 캐릭터의 공격 판정
    - 어빌리티 태스크 구현
    - 게임플레이 이벤트를 사용한 자동 어빌리티 발동
5. 캐릭터 어트리뷰트 설정
    - 캐릭터 어트리뷰트 설정
    - 캐릭터 어트리뷰트 계산
6. 게임플레이 이펙트의 활용
    - 어빌리티를 활용한 게임플레이 이펙트의 발동
    - 게임플레이 이펙트를 통한 어트리뷰트 변경
7. 어트리뷰트와 UI 연동
    - 어트리뷰트 변경 시 UI에서 노티를 받도록 설계
    - 타격 명중시 대상에 장식 이펙트 터트리기
    - 죽는 상태 구현
8. 아이템 상자 구현
    - 힐링 상자 구현
    - 도트 데미지 상자 구현
    - 무기 지급 상자 구현
    - 무기 버프 효과 부여 및 없애기
9. 캐릭터의 광역 스킬 구현
    - 어빌리티 태스크의 확장 설계
    - 캐릭터 광역 스킬 구현

## 강의 메모

### 1. 게임플레이 어빌리티 시스템 시작

- 어빌리티 시스템의 주 목적은 액터의 역할을 최소화시키는 것이다.
- 게임플레이 태그를 통해 어빌리티를 발동시킴으로써 어빌리티 클래스에 대한 의존성 역시 제거할 수 있다.
- 인스턴싱 정책이 `InstancedPerActor`인 경우 `ActivateAbility`에서 매번 레퍼런스를 가져오는 대신 `OnAvatarSet`에서 레퍼런스를 저장해두는 것이 더 나은 방법인 것 같습니다.

### 2. 캐릭터의 입력 처리

- 캐릭터 클래스에서 어빌리티 입력 ID와 어빌리티 클래스 매핑 설정을 통해 어빌리티 입력 바인딩 진행
- 어빌리티 태스크를 사용한 어빌리티 클래스 작성
- 입력 바인딩을 위해 입력 ID를 수동으로 설정해주는 것보다 입력 태그의 해시값을 입력 ID로 사용하는 것이 더 나을 것 같다.
- 어빌리티 입력 시 어빌리티 발동 및 취소를 위한 콜백 함수를 직접 구현하는 것보다 `UAbilitySystemComponent::PressInputID`, `UAbilitySystemComponent::ReleaseInputID`를 사용하는 것이 더 나을 것 같다.

### 3. 캐릭터의 콤보 공격 구현

- 콤보 공격 데이터 에셋에서 프레임 설정을 통해 콤보 입력 검사 시간 설정
    - 애님 노티파이에서 게임플레이 태그 이벤트로 입력 검사 타이밍을 설정하는 방법은 어떨까
    - 애님 노티파이나 프레임 설정을 통해 입력 검사 시간을 설정하면 로아의 콤보 공격 방식처럼 다른 행동 후에 콤보 공격을 이어나가는 방식은 불가능하기 때문에 데이터 에셋에서 수동으로 입력 시간을 설정하는 방법이 번거롭더라도 범용적일 것 같다.
- 콤보 공격의 다음 몽타주 섹션 이름은 이름 규칙을 통해 유추하는 방식인데 데이터 에셋에서 설정하는 것이 더 범용적일 것 같다.
    - 몽타주
    - 콤보 최대 횟수
    - 콤보 입력 시간
    - 다음 몽타주 섹션 이름
- `Retrigger Instanced Policy`를 사용하면 콤보 입력 검사 시간을 구간으로 설정하여 타이밍을 조절할 수 있을 것 같다.
  - 입력 검사 시작 타이머와 종료 타이머를 통해 `Retrigger Instanced Policy`를 토글하면 되지 않을까?

### 4. 캐릭터의 공격 판정

- 공격 어빌리티로 애님 몽타주 재생 > 애님 몽타주에 설정된 애님 노티파이에서 게임플레이 태그 이벤트 트리거 > 피격 판정 어빌리티 발동 > 피격 판정 태스크 생성 > 피격 판정을 위한 타겟 액터 스폰 및 타겟 데이터 기록 > 태스크 종료 > 피격 판정 어빌리티에서 게임플레이 이펙트 적용 > 어빌리티 적용
    - 타겟 액터 스폰 즉시 타겟 데이터 수집 후 소멸되기 때문에 어빌리티 태스크가 굳이 필요하지는 않지만 마법 캐스팅 스킬처럼 어빌리티 발동을 위한 추가 입력을 위해 대기 시간이 존재하는 경우도 있기 때문에 위처럼 구현한 것 같습니다.
    - 피격 판정 어빌리티보다는 공격 어빌리티에서 피격 판정을 위한 타겟 액터 클래스를 직접 생성 및 사용하는 것이 더 좋을 것 같습니다. 일반적으로 피격 판정은 1프레임 내에서 이루어지기 때문입니다. 대신 피격 판정 타이밍을 위해 게임플레이 태그 이벤트 수신을 위한 태스크가 필요할 것으로 생각됩니다.
    - 여러 스킬을 동시에 사용하는 경우처럼 피격 판정 이벤트는 여러 개일 수 있기 때문에 서로 다른 이벤트 태그를 사용해야 합니다. 각 스킬 별로 별도의 이벤트 태그를 작성하는 것은 비효율적이기 때문에 어빌리티 태그 자체를 이벤트 태그로 활용하는 것이 좋을 것 같습니다.

### 5. 캐릭터 어트리뷰트 설정

- `ASC`가 존재하는 클래스에 사용할 `AttributeSet`을 서브 오브젝트로 생성하면 자동으로 `ASC` 관리 대상으로 지정되지만 블루프린트에서 추가 설정이 불가능하다는 단점이 있습니다. 
    - `TArray<TSubclassOf<UAttributeSet>>` 프로퍼티와 `UAbilitySystem::AddSpawnedAttribute`을 사용하여 동적으로 추가할 수 있도록 하는 것이 좋을 것 같습니다.
- 어트리뷰트 값 범위 제한은 `PreAttributeChange`에서 하는 것이 좋은 것 같습니다. 아직은 굳이 `PostGameplayEffectExecute`에서 설정하는 이유를 잘 모르겠습니다. 
    - 스냅샷으로 인한 `CurrentValue` 재계산은 `PreAttributeChanage`가 호출되지 않기 때문에 값 범위 제한이 추가로 필요하다고 합니다.

### 6. 게임플레이 이펙트의 활용

- 커브 데이터 테이블을 통해 레벨에 따른 캐릭터 어트리뷰트 설정 기능과 콤보 공격 시 데미지 계수 증가 기능 등을 구현할 수 있습니다.
- `SetByCaller` 옵션을 통해 동일한 게임플레이 이펙트를 사용하더라도 어빌리티에 따라 동적인 데미지를 전달할 수 있습니다. 다만 고정값만 전달할 수 있으며 여러 스탯에 의한 계산식을 이용하기 위해서는 스냅샷 기능을 대신 사용하는 것이 좋을 것 같습니다.
    - 테스트는 아직 진행되지 않았습니다만 구상으로는 스킬을 발동한 순간 일시적으로 캐릭터에 스킬 데미지 적용을 위한 버프형 게임플레이 이펙트 적용 후 스냅샷으로 데미지 게임플레이 이펙트 스펙을 생성한 다음 스킬에 의한 버프형 게임플레이 이펙트를 제거하는 방식입니다.

### 7. 어트리뷰트와 UI 연동

- `UserWidget` 클래스에 `SetOwner` 메서드를 작성하여 바인딩할 `ASC`를 주입
- `WidgetComponent`의 `InitWidget`에서 `UserWidget` 클래스에 `Owner` 주입
- `AttributeSet` 클래스에서 죽음 처리를 위한 태그 부착 및 델리게이트 호출 진행
    - 태그 부착 이벤트 자체를 델리게이트로서 활용하는 것이 나을 것 같다.
    - 배그처럼 사망 이전에 다운 기능을 구현할 수도 있기 때문에 태그 부착 메서드는 가상 함수로 작성하는 것이 좋을 것 같다.
- 무적 기능은 단순히 태그 부착으로 구현하는 대신 `AttributeSet`에서 태그 검사 후 데미지를 무시하는 방식으로 진행

### 8. 아이템 상자 구현

- `NotifyActorBeginOverlap`에서 트리거 이벤트 감지
- `SetLifeSpan`을 통해 자동 파괴 기능 구현

### 9. 캐릭터의 광역 스킬 구현

- 거리에 따라 데미지를 다르게 적용하기 위한 GameplayEffectExecutionCalculation 클래스 작성
- 어빌리티 코스트 게임플레이 이펙트 설정만 하면 자동으로 코스트 소모가 적용된다고 설명하지만 실제로는 그렇지 않습니다. 언리얼 버전 차이로 인한 것으로 보이며 `CommitAbility`를 호출해주어야 코스트가 적용됩니다.
- 어빌리티 쿨다운 게임플레이 이펙트 설정을 하고 쿨다운 게임플레이 태그를 `ActivationBlocked Tags`에 설정하라고 설명하셨지만 설정하지 않아도 내부적으로 블록 처리됩니다.
